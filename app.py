from flask import Flask, render_template, request, send_file
from weasyprint import HTML
import pdfplumber
import re
import json
import os
import subprocess
from datetime import datetime
from bs4 import BeautifulSoup
from mistralai import Mistral
from mistralai.models import UserMessage
import zipfile
import io

app = Flask(__name__)

# Set up Mistral AI client
MISTRAL_API_KEY = os.environ.get("MISTRAL_API_KEY")
client = Mistral(api_key=MISTRAL_API_KEY)

def extract_text_from_pdf(pdf_file):
    pdf_file.seek(0)
    text = ""
    with pdfplumber.open(pdf_file) as pdf:
        for page in pdf.pages:
            text += page.extract_text() + "\n\n"
    return text

def extract_cv_details(cv_text):
    # Extract basic contact info with regex
    contact_info = {
        "email": re.search(r"[\w\.-]+@[\w\.-]+", cv_text),
        "phone": re.search(r"\+?\d[\d\- ]{7,}\d", cv_text),
        "linkedin": re.search(r"(linkedin\.com/|linkedin\.com/in/)\S+", cv_text, re.I),
        "github": re.search(r"github\.com/\S+", cv_text, re.I),
        "portfolio": re.search(r"(https?://)?(www\.)?\S+\.(com|io|net|tech|dev)\b", cv_text, re.I)
    }
    contact_info = {k: v.group(0) if v else "" for k, v in contact_info.items()}
    
    prompt = f"""Extract structured details from this resume. Include dates where available.
Return JSON with these keys:
- name (string)
- education (list of {{degree, institution, start_date, end_date}})
- experience (list of {{position, company, start_date, end_date, description}})
- skills (list of strings)
- certifications (list of {{name, date, issuer}})
- projects (list of {{name, start_date, end_date, description}})
- interests (list of strings) [if mentioned]

Resume Text:
{cv_text[:5000]}  # Truncate for token limits
"""
    response = client.chat.complete(
        model="mistral-small",
        messages=[{"role": "user", "content": prompt}]
    )
    try:
        extracted_data = json.loads(response.choices[0].message.content)
    except json.JSONDecodeError:
        extracted_data = {}
    return {**contact_info, **extracted_data}

def convert_pdf_to_html(pdf_file):
    """
    Saves the uploaded PDF to a temporary file, uses pdf2htmlEX to convert it to HTML,
    reads the resulting HTML, and returns it as a string.
    """
    temp_pdf_path = "temp_upload.pdf"
    pdf_file.seek(0)
    with open(temp_pdf_path, "wb") as f:
        f.write(pdf_file.read())
    output_html_path = "converted.html"
    command = ["pdf2htmlEX", temp_pdf_path, output_html_path]
    subprocess.run(command, check=True)
    with open(output_html_path, "r", encoding="utf-8") as f:
        html_content = f.read()
    os.remove(temp_pdf_path)
    # Optionally, you might keep or archive output_html_path
    return html_content

def customize_html(html_content, cv_data, job_description):
    """
    Uses BeautifulSoup to parse the converted HTML and then injects new content.
    Here we simply prepend a customized section generated by the AI.
    """
    soup = BeautifulSoup(html_content, "html.parser")
    
    # Generate customized content using the candidate details and job description.
    prompt = f"""Customize the resume content based on the candidate's details and the job description.
Candidate Details:
{json.dumps(cv_data, indent=2)}

Job Description:
{job_description}

Provide revised resume content in HTML format that highlights the candidate’s strengths for this job. 
Keep the structure minimal so it can be integrated into the existing layout.
"""
    response = client.chat.complete(
         model="mistral-small",
         messages=[{"role": "user", "content": prompt}]
    )
    custom_html = response.choices[0].message.content
    custom_fragment = BeautifulSoup(custom_html, "html.parser")
    
    # Insert the customized content at the beginning of the <body> if available.
    if soup.body:
         soup.body.insert(0, custom_fragment)
    else:
         soup.insert(0, custom_fragment)
    return str(soup)

def generate_cover_letter(cv_data, job_description):
    prompt = f"""Write a personalized cover letter for the given job.
    
Candidate Details:
{json.dumps(cv_data, indent=2)}

Job Description:
{job_description}

Structure:
- Addressing the Hiring Manager (if possible)
- Introduction (Highlight most relevant skills)
- Body (Explain how the candidate’s experience and projects match the job)
- Conclusion (Express enthusiasm and request for an interview)

Return the cover letter in HTML format.
"""
    response = client.chat.complete(
        model="mistral-small",
        messages=[{"role": "user", "content": prompt}]
    )
    return response.choices[0].message.content

def generate_pdf(html_content, output_path):
    HTML(string=html_content).write_pdf(output_path)

@app.route("/", methods=["GET", "POST"])
def form():
    if request.method == "POST":
        cv_file = request.files["cv"]
        job_description = request.form["job_description"]
        document_type = request.form["document_type"]  # "resume" or "cover_letter"
        
        # Extract text from PDF for candidate details
        cv_file.seek(0)
        cv_text = extract_text_from_pdf(cv_file)
        cv_data = extract_cv_details(cv_text)
        
        candidate_name = cv_data.get("name", "Candidate").replace(" ", "_")
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        pdf_filename = f"{candidate_name}_{timestamp}.pdf"
        html_filename = f"{candidate_name}_{timestamp}.html"
        
        if document_type == "resume":
            # Convert the original PDF resume to HTML.
            cv_file.seek(0)
            original_html = convert_pdf_to_html(cv_file)
            # Customize the HTML content with job-specific enhancements.
            customized_html = customize_html(original_html, cv_data, job_description)
        else:
            customized_html = generate_cover_letter(cv_data, job_description)
        
        # Generate PDF from the customized HTML.
        generate_pdf(customized_html, pdf_filename)
        # Save the customized HTML to a file.
        with open(html_filename, "w", encoding="utf-8") as f:
            f.write(customized_html)
        
        # Package both the PDF and the HTML into a ZIP file for download.
        zip_buffer = io.BytesIO()
        with zipfile.ZipFile(zip_buffer, "w", zipfile.ZIP_DEFLATED) as zip_file:
            zip_file.write(pdf_filename)
            zip_file.write(html_filename)
        zip_buffer.seek(0)
        
        # Clean up temporary files.
        os.remove(pdf_filename)
        os.remove(html_filename)
        
        # Return the ZIP file as an attachment.
        return send_file(zip_buffer, as_attachment=True,
                         download_name=f"{candidate_name}_{timestamp}.zip",
                         mimetype="application/zip")
    
    return render_template("form.html")

@app.route('/pdf2html-version')
def pdf2html_version():
    try:
        version = subprocess.check_output(["pdf2htmlEX", "--version"]).decode("utf-8")
    except Exception as e:
        version = str(e)
    return f"pdf2htmlEX version: {version}"

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=int(os.environ.get("PORT", 10000)))
